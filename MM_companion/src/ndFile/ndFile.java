package ndFile;


import ij.io.FileInfo;
import ij.io.OpenDialog;
import ij.measure.Calibration;
import java.io.*;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.logging.Level;
import java.util.logging.Logger;
import ndFile.content.event;
import ndFile.content.wave;

/*
 *  ndFile.java
 * 
 *  Created on 19 juil. 2010, 10:51:15
 * 
 *  Copyright (C) 2010 Fabrice P. Cordelieres
 * 
 *  License:
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 3 of the License, or
 *  (at your option) any later version.

 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.

 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.

 * 

 */

/**
 * This class provides a way to read/modify/save nd files generated by the MultiDimensionnal
 * Acquisition tool from the Metamorph software
 * @author fab
 */
public class ndFile {
    /** Fields delimiters used within the nd files **/
    public static final String[] TAGS={"NDInfoFile", "Description", "StartTime","DoTimelapse", "NTimePoints", "DoStage",
                                       "NStagePositions", "Stage", "DoWave", "ImageName", "NWavelengths", "WaveName", "WaveDoZ",
                                       "WavePointsCollected", "DoZSeries", "NZSteps", "ZStepSize","WaveInFileName", "NEvents", "Event", "EndFile"};
    
    /** Used in the buildImageList function **/
    public static int ALL_WAVES=-1;

    /** Directory **/
    public String Directory="";

    /** Basename **/
    public String BaseName="";

    /** nd file version **/
    public String NDInfoFile="";

    /** Description **/
    public String Description="";

    /** StartTimes **/
    public ArrayList<Date> StartTime=new ArrayList<Date>();

    /** Time lapse performed ? true/false **/
    public boolean DoTimeLapse=false;

    /** Number of Time points **/
    public int NTimePoints=1;

    /** Multiple stage positions acquired ? true/false **/
    public boolean DoStage=false;

    /** Number of stage positions **/
    public int NStagePositions=1;

    /** Labels for stage positions **/
    public ArrayList<String> Stage=new ArrayList<String>();

    /** Multiple wave acquired ? true/false **/
    public boolean DoWave=false;

    /** Name of image if multiple wavelength not acquired **/
    public String ImageName="";

    /** Number of wavelengths acquired **/
    public int NWavelengths=0;

    /** Stores informations relative to wavelengths **/
    public ArrayList<wave> Waves=new ArrayList<wave>();

   /** Z series performed ? true/false **/
    public boolean DoZSeries=false;

    /** Number of Z steps performed **/
    public int NZSteps=1;

    /** Distance between z steps **/
    public double ZStepSize=0.0;

    /** Is wave encoded in name ? true/false**/
    public boolean WaveInFileName=false;

    /** Number of events **/
    public int NEvents=0;

    /** Stores the events **/
    public ArrayList<event> Events=new ArrayList<event>();

    /**Stacks extension**/
    public String stackExtension="TIF";

    /** Stores FileInfos for each wave**/
    public ArrayList<FileInfo> infos=new ArrayList<FileInfo>();

    /** Stores calibration **/
    public Calibration cal=null;
    
    
     /** BufferedReader used to read the nd file **/
    BufferedReader in=null;

    /** Stores the line currently read **/
    String line="";
    
    
    /** Debug mode ON/OFF **/
    public static boolean debug=false;

    
    /**
     * Either creates a new empty ndFile or reads an existing one in case the showDialog 
     * argument is set to true
     * @param showDialog should be true to display a open dialog box
     */
    public ndFile(boolean showDialog){
        if(showDialog){
            OpenDialog od=new OpenDialog("Select the nd file in the source folder", null, "*.nd");
            Directory=od.getDirectory();
            BaseName=od.getFileName().replace(".nd", "").replace(".ND", "");
            read();
        }
    }
    
    /**
     * Starts the process of reading a nd file for which the directory and file
     * name are provided
     * @param directory directory where the file is stored
     * @param fileName name of the nd file to be read
     */
    public ndFile(String directory, String fileName){
        Directory=directory;
        BaseName=fileName.replace(".nd", "").replace(".ND", "");
        read();
    }
    
    /**
     * Reads and stores the content of the nd file
     */
    public final void read(){
        try {
            in= new BufferedReader(new FileReader(Directory + BaseName+".nd"));

            //Check for nd file
            line=in.readLine();
            int tag=getTag(line);
            if(tag!=0) throw new IllegalArgumentException("This is not a nd file !");

            while (tag!=TAGS.length-1){
                switch (tag){
                    //NDInfoFile
                    case 0: NDInfoFile=getArgument(); break;
                    //Description
                    case 1: Description=getArgument(); break;
                    //StartTime
                    case 2: SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd hh:mm:ss");
                            try {
                                StartTime.add(sdf.parse(getArgument()));
                            } catch (ParseException ex) {
                                Logger.getLogger(ndFile.class.getName()).log(Level.SEVERE, null, ex);
                            }
                            break;
                    //DoTimeLapse
                    case 3: DoTimeLapse=Boolean.parseBoolean(getArgument()); break;
                    //NTimePoints
                    case 4: NTimePoints=Integer.parseInt(getArgument()); break;
                    //DoStage
                    case 5: DoStage=Boolean.parseBoolean(getArgument()); break;
                    //NStagePositions
                    case 6: NStagePositions=Integer.parseInt(getArgument()); break;
                    //Stage
                    case 7: Stage.add(getArgument()); break;
                    //DoWave
                    case 8: DoWave=Boolean.parseBoolean(getArgument()); break;
                    //ImageName
                    case 9: ImageName=getArgument(); break;
                    //NWavelengths
                    case 10: NWavelengths=Integer.parseInt(getArgument()); break;
                    //WaveName
                    case 11: Waves.add(new wave()); Waves.get(Waves.size()-1).WaveName=getArgument(); break;
                    //WaveDoZ
                    case 12: Waves.get(Waves.size()-1).WaveDoZ=Boolean.parseBoolean(getArgument()); break;
                    //WavePointsCollected
                    case 13: Waves.get(getWavePointsCollectedNumber()-1).WavePointsCollected=getWavePointsCollected(); break;
                    //DoZSeries
                    case 14: DoZSeries=Boolean.parseBoolean(getArgument()); break;
                    //NZSteps
                    case 15: NZSteps=Integer.parseInt(getArgument()); break;
                    //ZStepSize
                    case 16: ZStepSize=Double.parseDouble(getArgument()); break;
                    //WaveInFileName
                    case 17: WaveInFileName=Boolean.parseBoolean(getArgument()); break;
                    //NEvents
                    case 18: NEvents=Integer.parseInt(getArgument()); break;
                    //Events
                    case 19: Events.add(new event(getArgument())); break;
                    default: System.out.println("Not yet supported tag: "+line);
                }
                if(tag!=1) line=in.readLine();
                tag=getTag(line);
            }
            in.close();
            getStackExtension();
            if(debug) System.out.println(toString());
        } catch (IOException ex) {
            Logger.getLogger(ndFile.class.getName()).log(Level.SEVERE, "An error occured while reading the Metamorph nd file", ex);
        } finally {
            try {
                in.close();
            } catch (IOException ex) {
                Logger.getLogger(ndFile.class.getName()).log(Level.SEVERE, "An error occured while reading the Metamorph nd file", ex);
            }
        }
    }
    
    /**
     * Return an integer specific of the tag of the input line
     * @param line String to analyse
     * @return a tag specific integer
     */
    private int getTag(String line){
        int tag=-1;
        for (int i=0; i<TAGS.length; i++){
            if(line.contains(TAGS[i])){
                tag=i;
                i=TAGS.length;
            }
        }
        return tag;
    }
    
    /**
     * Reads the current line's argument
     * @return the argument as a String
     */
    private String getArgument(){
        String arg=line.substring(line.indexOf("\", ")+3).replace("\"", "");

        if(line.contains("Description")){
            try {
                line = in.readLine();
                while (!line.contains("\", ")) {
                    arg+="\n"+line;
                    line = in.readLine();
                }
            } catch (IOException ex) {
                Logger.getLogger(ndFile.class.getName()).log(Level.SEVERE, null, ex);
            }
        }

        return arg;
    }

    /**
     * Split coma seperated integers representing WavePointsCollected into an array of integers
     * @return the WaveNumber of the current WavePointsCollected
     */
    private int getWavePointsCollectedNumber(){
        return Integer.parseInt(getArgument().split(", ")[0]);
    }

    /**
     * Split coma seperated integers representing WavePointsCollected into an array of integers
     * @return the WavePointsCollected as an array of integers
     */
    private ArrayList<Integer> getWavePointsCollected(){
        String[] arg=getArgument().split(", ");
        ArrayList<Integer> out=new ArrayList<Integer>();
        for(int i=1; i<arg.length; i++) out.add(Integer.parseInt(arg[i]));
        return out;
    }

    /**
     * Determine the stack file extension.
     */
    private void getStackExtension(){
        stackExtension=".TIF";
        File dir=new File(Directory);
        String[] fileList=dir.list();
        for (int i=0; i<fileList.length; i++){
            if(fileList[i].startsWith(BaseName) && fileList[i].endsWith(".STK")){
                stackExtension=".STK";
                i=(int) dir.length();
            }
        }
    }
    
    /**
     * Saves the current ndFile to a file
     * @param filePath path of the nd file to write
     */
    public void write(String filePath){
        if(!filePath.endsWith(".nd")) filePath=filePath+".nd";
        BufferedWriter out = null;
        try {
            out = new BufferedWriter(new FileWriter(filePath));
            out.write(getNdFileContent());
        } catch (IOException ex) {
            Logger.getLogger(ndFile.class.getName()).log(Level.SEVERE, null, ex);
        } finally {
            try {
                out.close();
            } catch (IOException ex) {
                Logger.getLogger(ndFile.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }
    
    /**
     * Generates a string containing all informations, formatted as in the original nd file
     * @return a String containing the content of the nd file
     */
    public String getNdFileContent(){
        String out="\"NDInfoFile\", "+NDInfoFile+"\n";
        out+="\"Description\", "+Description+"\n";

        for (int i=0; i<StartTime.size(); i++) out+="\"StartTime"+(i+1)+"\", "+new SimpleDateFormat("yyyyMMdd HH:mm:ss").format(StartTime.get(i))+"\n";

        out+="\"DoTimelapse\", "+(DoTimeLapse+"\n").toUpperCase();
        if(DoTimeLapse) out+="\"NTimePoints\", "+NTimePoints+"\n";

        out+="\"DoStage\", "+(DoStage+"\n").toUpperCase();
        if(DoStage){
            out+="\"NStagePositions\", "+NStagePositions+"\n";
            for (int i=0; i<NStagePositions; i++) out+="\"Stage"+(i+1)+"\", \""+Stage.get(i)+"\"\n";
        }

        out+="\"DoWave\", "+(DoWave+"\n").toUpperCase();
        if(DoWave){
            out+="\"NWavelengths\", "+NWavelengths+"\n";
            for (int i=0; i<NWavelengths; i++){
                out+="\"WaveName"+(i+1)+"\", \""+Waves.get(i).WaveName+"\"\n";
                out+="\"WaveDoZ"+(i+1)+"\", "+(Waves.get(i).WaveDoZ+"\n").toUpperCase();
            }
            for (int i=0; i<NWavelengths; i++){
                if(Waves.get(i).WavePointsCollected!=null){
                    out+="\"WavePointsCollected\", "+(i+1);
                    for(int j=0; j<Waves.get(i).WavePointsCollected.size(); j++) out+=", "+Waves.get(i).WavePointsCollected.get(j);
                    out+="\n";
                }
            }
        }else{
            out+="\"ImageName\", "+ImageName+"\n";
        }
        out+="\"DoZSeries\", "+(DoZSeries+"\n").toUpperCase();
        if(DoZSeries){
            out+="\"NZSteps\", "+NZSteps+"\n";
            out+="\"ZStepSize\", "+ZStepSize+"\n";
        }
        out+="\"WaveInFileName\", "+(WaveInFileName+"\n").toUpperCase();
        out+="\"NEvents\", "+NEvents+"\n";
        for (int i=0; i<NEvents; i++) out+="\"Event"+(i+1)+"\", \""+Events.get(i).Type+"\", \""+Events.get(i).Description+"\", \""
                                           +new SimpleDateFormat("yyyyMMdd HH:mm:ss").format(Events.get(i).Time)+"\", "
                                           +Events.get(i).EventOnAllPositionsFromNow+", "+Events.get(i).TimePoint+", "+Events.get(i).Position+", "
                                           +(Events.get(i).AllPositions+", ").toUpperCase()+Events.get(i).Color+"\n";
        out+="\"EndFile\"";

        return out;
    }

    @Override
    public String toString(){
        String out="***** "+BaseName+" *****\n";
        
        out+="NDInfoFile: "+NDInfoFile+"\n";
        out+="Description: "+Description+"\n";

        for (int i=0; i<StartTime.size(); i++) out+="StartTime"+(i+1)+": "+StartTime.get(i)+"\n";

        out+="DoTimeLapse: "+DoTimeLapse+"\n";
        if(DoTimeLapse) out+="NTimePoints: "+NTimePoints+"\n";

        out+="DoStage: "+DoStage+"\n";
        if(DoStage){
            out+="NStagePositions: "+NStagePositions+"\n";
            for (int i=0; i<NStagePositions; i++) out+="Stage"+(i+1)+": "+Stage.get(i)+"\n";
        }

        out+="DoWave: "+DoWave+"\n";
        if(DoWave){
            out+="NWavelengths: "+NWavelengths+"\n";
            for (int i=0; i<NWavelengths; i++){
                out+="WaveName"+(i+1)+": "+Waves.get(i).WaveName+"\n";
                out+="WaveDoZ"+(i+1)+": "+Waves.get(i).WaveDoZ+"\n";
                if(Waves.get(i).WavePointsCollected!=null){
                    out+="WavePointsCollected: ";
                    for(int j=0; j<Waves.get(i).WavePointsCollected.size(); j++) out+=Waves.get(i).WavePointsCollected.get(j)+" ";
                    out+="\n";
                }
            }
        }else{
            out+="ImageName: "+ImageName+"\n";
        }
        out+="DoZSeries: "+DoZSeries+"\n";
        if(DoZSeries){
            out+="NZSteps: "+NZSteps+"\n";
            out+="ZStepSize: "+ZStepSize+"\n";
        }
        out+="WaveInFileName: "+WaveInFileName+"\n";
        out+="NEvents: "+NEvents+"\n";
        for (int i=0; i<NEvents; i++) out+="Event"+(i+1)+": "+Events.get(i).Type+", "+Events.get(i).Description+", "+Events.get(i).Time+", "
                                           +Events.get(i).EventOnAllPositionsFromNow+", "+Events.get(i).TimePoint+", "+Events.get(i).Position+", "
                                           +Events.get(i).AllPositions+", "+Events.get(i).Color+"\n";

        return out;
    }

    /**
     * Returns the positions' names as a String array
     * @return the positions' names as a String array
     */
    public String[] getPosNames(){
        String[] out=new String[Stage.size()];
        for (int i=0; i<Stage.size(); i++) out[i]=Stage.get(i);
        return out;
    }
    
    /**
     * Returns the wavelengths' names as a String array
     * @return the wavelengths' names as a String array
     */
    public String[] getWaveNames(){
        String[] out=new String[Waves.size()];
        for (int i=0; i<Waves.size(); i++) out[i]=Waves.get(i).WaveName;
        return out;
    }
    
    /**
     * Returns all events stored in the nd file as a String
     * @return a String containing all events
     */
    public String eventsToString(){
        String out="";
        for (int i=0; i<Events.size(); i++) out+=Events.get(i).toString(StartTime.get(0), NTimePoints, NStagePositions)+"\n";
        return out;
    }

    /**
     * Build the name of the file based on the wave/position and timepoint
     * @param position stage position
     * @param wave wavelength
     * @param timepoint timepoint
     * @return the file name as a String
     */
    public String getFileName(int position, int wave, int timepoint){
        String out=BaseName;
        out+=WaveInFileName && !Waves.isEmpty()?"_w"+(wave+1)+Waves.get(wave).getFileName():"";
        out+=DoStage?"_s"+(position+1):"";
        out+=DoTimeLapse?"_t"+timepoint:"";
        out+=((!Waves.isEmpty() && Waves.get(wave).WaveDoZ)||(Waves.isEmpty() && DoZSeries))?stackExtension:".TIF";
        return out;
    }

    /**
     * Builds a list of the image filenames for the provided wavelength and position
     * @param position position
     * @param wave wavelength (-1 to use all wavelengths)
     * @param startTime start timepoint [0, NTimePoints-1]
     * @param stopTime stop timepoint [0, NTimePoints-1]
     * @param overWPC overrides the wave point collection info by creating the list
     * of all files, including the time points that were not collected
     * @return a String ArrayList containing all filenames.
     */
    public ArrayList<String> getImageList(int position, int wave, int startTime, int stopTime, boolean overWPC){
       ArrayList<String> out=new ArrayList<String>();
       int startWave=wave==ALL_WAVES?0:wave;
       int stopWave=wave==ALL_WAVES?(NWavelengths==0?1:NWavelengths):wave+1;
       
       for(int i=startWave; i<stopWave; i++){
            ArrayList<Integer> wavePointsCollection=!Waves.isEmpty()?Waves.get(i).WavePointsCollected:null;
            if(wavePointsCollection==null || overWPC){
                for(int j=startTime; j<=stopTime; j++) out.add(getFileName(position, i, j));
            }else{
                for(int j=0; j<wavePointsCollection.size(); j++){
                    int wavePoint=wavePointsCollection.get(j);
                    if(wavePoint>=startTime && wavePoint<=stopTime ) out.add(getFileName(position, i, wavePoint));
                }
            }
        }

        return out;
    }
}
